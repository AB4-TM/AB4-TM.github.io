<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <link href="styles.css" rel="stylesheet">
	<title>HT7627 UART</title>
	<script type="text/javascript" src="dygraph.min.js"></script>
	<script type="text/javascript" src="fft.js"></script>
</head>
<body>

<p>
  <input type='file' accept='.bin' onchange='openFile(event)'><br>
</p>
  <button id="clrBtn" type="button">CLEAR</button>
  <button id="butOpen" type="button">Open</button>
  <button id="getVerBtn" type="button">GET VER</button>
  <button id="SaveBtn" type="button">SAVE GRAPH TO CSV</button>
  <button id="butBufSave" type="button">Save buf.bin</button>
</p>
  <button id="defaultAdcSelBtn" type="button">default ADC</button>
  <button id="AdcDataSelBtn" type="button">ADC+SPI</button>
  <button id="EmulDataSelBtn" type="button">EMUL+SPI</button>
  <button id="AaDataSelBtn" type="button">0xAA+SPI</button>
  <button id="startCollectionBtn" type="button">START COLLECTION</button>
  <button id="startCycleCollectionBtn" type="button">START CYCLE COLLECTION</button>
  <input type="checkbox" name="radio_set" id="checkboxFft" " >FFT</input>  
</p>
  <input type="checkbox" id="chmask6" name="chmask6" >
  <input type="checkbox" id="chmask5" name="chmask5" checked>
  <input type="checkbox" id="chmask4" name="chmask4" checked>
  <input type="checkbox" id="chmask3" name="chmask3" checked>
  <input type="checkbox" id="chmask2" name="chmask2" checked>
  <input type="checkbox" id="chmask1" name="chmask1" checked>
  <input type="checkbox" id="chmask0" name="chmask0" checked>
  <button id="setMaskBtn" type="button">set mask</button>
  <button id="setMask2048Btn" type="button">set mask 2048</button>
  <br>
  <input type="checkbox" name="radio_set_7" id="checkbox7" onclick="SetСhSel(6)" >In</input>
  <input type="checkbox" name="radio_set_6" id="checkbox6" onclick="SetСhSel(5)" >Ic</input>
  <input type="checkbox" name="radio_set_5" id="checkbox5" onclick="SetСhSel(4)" >Ib</input>
  <input type="checkbox" name="radio_set_4" id="checkbox4" onclick="SetСhSel(3)" >Ia</input>
  <input type="checkbox" name="radio_set_3" id="checkbox3" onclick="SetСhSel(2)" >Uc</input>
  <input type="checkbox" name="radio_set_2" id="checkbox2" onclick="SetСhSel(1)" checked>Ub</input>
  <input type="checkbox" name="radio_set_1" id="checkbox1" onclick="SetСhSel(0)" >Ua</input>
</p>
  <input id="input_addr" type="text" value="0x4001B000">
  <input id="input_n" type="text"  value="16">
  <input id="input_data" type="text"  value="CA FE">
  <button id="read_u8_Btn" type="button">read u8</button>
  <button id="read_u32_Btn" type="button">read u32</button>
  <button id="write_u8_Btn" type="button">write u8</button>
  <button id="write_u32_Btn" type="button">write u32</button>
</p>
  <button id="read_data" type="button">read data</button>
  <button id="read_angle" type="button">read angle</button>
</p>
  <button id="read_gain" type="button">read gain</button>
  <button id="write_gain_0" type="button">set gain 0</button>
  <button id="write_gain_8" type="button">set gain 8</button>
  <button id="write_current_gain_8" type="button">set current gain 8</button>
  

<div style="height: auto; width: auto; text-align: center;">
<div id="div_v"	style="height:400px;"></div>
<div id='labdiv' style=></div>

<div style="height: auto; width: auto; text-align: left; overflow: auto;">
<div id="terminal">
	<div>Версия V0.0.1</div>
</div>

</body>


<script type="text/javascript">
"use strict";

var devicename = "#0" ;
var showDataIndex = 0 ;


function log(data, type = '') {
  $('terminal').insertAdjacentHTML('beforeend',
      '<div' + (type ? ' class="' + type + '"' : '') + '>' + data + '</div>');
}
function beginlog(data, type = '') {
  $('terminal').insertAdjacentHTML('afterbegin',
      '<div' + (type ? ' class="' + type + '"' : '') + '>' + data + '</div>');
}
var $ = function(id) {
	return document.getElementById(id);
}
function delay(ms) {
  return new Promise((resolve, reject) => {
	setTimeout(resolve, ms);
  });
}
function hex(number, length) {
	var str = (number.toString(16)).toUpperCase();
	while (str.length < length) str = '0' + str;
	return str;
}

function dec2bin(dec) {
  return (dec >>> 0).toString(2);
}

var collected_data = [] ;
var collected_mask ;
var collected_points ;
var ch_in_use = 0 ;
var graph_labels = [] ;

const BYTES_IN_ONE_CHANNEL_DATA = 3 ;
function SetСhSel(ch_sel) {

    ch_in_use = 0 ;
    if( collected_mask & (1<<0) ) { ch_in_use++; }
    if( collected_mask & (1<<1) ) { ch_in_use++; }
    if( collected_mask & (1<<2) ) { ch_in_use++; }
    if( collected_mask & (1<<3) ) { ch_in_use++; }
    if( collected_mask & (1<<4) ) { ch_in_use++; }
    if( collected_mask & (1<<5) ) { ch_in_use++; }
    if( collected_mask & (1<<6) ) { ch_in_use++; }
    
    datau = [] ; showDataIndex = 0 ;
    for (var i=0; i<collected_points; i++) {
      var push_data = [showDataIndex++, ] ;
      var index_in_buf = i*BYTES_IN_ONE_CHANNEL_DATA*ch_in_use ;
      for (var _ch=0; _ch<7; _ch++) {
          if( collected_mask & (1<<_ch) ) { 
              var raw_3byte_value = ((collected_data[index_in_buf+2] << 16) + (collected_data[index_in_buf+1] << 8) + collected_data[index_in_buf+0]) ;
              index_in_buf += BYTES_IN_ONE_CHANNEL_DATA ;
              raw_3byte_value = raw_3byte_value >> 2 ;
              if(raw_3byte_value & (0x1 << 21)) { raw_3byte_value = -((0x1 << 21) - (raw_3byte_value & ~(0x1 << 21))) ; }
              
              if( (_ch == 0) && ($('checkbox1').checked) ) { push_data.push(raw_3byte_value);}
              if( (_ch == 1) && ($('checkbox2').checked) ) { push_data.push(raw_3byte_value);}
              if( (_ch == 2) && ($('checkbox3').checked) ) { push_data.push(raw_3byte_value);}
              if( (_ch == 3) && ($('checkbox4').checked) ) { push_data.push(raw_3byte_value);}
              if( (_ch == 4) && ($('checkbox5').checked) ) { push_data.push(raw_3byte_value);}
              if( (_ch == 5) && ($('checkbox6').checked) ) { push_data.push(raw_3byte_value);}
              if( (_ch == 6) && ($('checkbox7').checked) ) { push_data.push(raw_3byte_value);}
          }
      }
      
      graph_labels = ['num',] ;
      if( (collected_mask & (1<<0)) && ($('checkbox1').checked) ) { graph_labels.push('Ua');}
      if( (collected_mask & (1<<1)) && ($('checkbox2').checked) ) { graph_labels.push('Ub');}
      if( (collected_mask & (1<<2)) && ($('checkbox3').checked) ) { graph_labels.push('Uc');}
      if( (collected_mask & (1<<3)) && ($('checkbox4').checked) ) { graph_labels.push('Ia');}
      if( (collected_mask & (1<<4)) && ($('checkbox5').checked) ) { graph_labels.push('Ib');}
      if( (collected_mask & (1<<5)) && ($('checkbox6').checked) ) { graph_labels.push('Ic');}
      if( (collected_mask & (1<<6)) && ($('checkbox7').checked) ) { graph_labels.push('In');}
      //console.log("push_data", push_data);
      datau.push(push_data); 
    }
    
    grapTitle = 'ADC data' ;
    if(datau[0].length > 2) {
        var fft_1_input_data = [] ;
        var fft_2_input_data = [] ;
        for (var i=0; i<collected_points; i++) { fft_1_input_data.push(datau[i][1]); fft_2_input_data.push(datau[i][2]); }
        var fft_1_out = FFT(fft_1_input_data);
        var fft_2_out = FFT(fft_2_input_data);
        
        var freq_step = 25600 / fft_1_input_data.length ;
        var index_50Hz_point = 50 / freq_step ;
        
        var phase_50Hz_1 = Math.atan(fft_1_out[index_50Hz_point].im / fft_1_out[index_50Hz_point].re);
        var phase_50Hz_2 = Math.atan(fft_2_out[index_50Hz_point].im / fft_2_out[index_50Hz_point].re);
        
        var angle = 180*(phase_50Hz_1-phase_50Hz_2)/3.1415296 ;
        if(angle >  90) { angle = 180 - angle ; }
        if(angle < -90) { angle = 180 + angle ; }
        
        grapTitle = 'angle ' + angle.toFixed(3) ; 
        console.log('phases', phase_50Hz_1, phase_50Hz_2, angle.toFixed(3));
    }
    
    if($('checkboxFft').checked) {
        var fft_input_data = [] ;
        for (var i=0; i<collected_points; i++) { fft_input_data.push(datau[i][1]); }
        
        //console.log("datau", datau);
        //console.log("fft_input_data", fft_input_data);

        var fft_out = FFT(fft_input_data);
        var X_real = new Array(fft_input_data.length / 2).fill(0);
        var X_imag = new Array(fft_input_data.length / 2).fill(0);
        var X_abs = new Array(fft_input_data.length / 2).fill(0);

        datau = [] ;
        var freq_step = 25600 / fft_input_data.length ;
        for (var i = 0; i < fft_input_data.length / 2; i += 1) {
          X_real[i] = fft_out[i].re;
          X_imag[i] = fft_out[i].im;
          X_abs[i] = Math.sqrt(fft_out[i].re * fft_out[i].re + fft_out[i].im * fft_out[i].im);
          datau.push([i*freq_step, X_abs[i]]); 
        }    
        console.log("X_abs", X_abs);
    }    
    
    ShowGrf();
}

class SerialController {
	async init(init_cb) {
		if ('serial' in navigator) {
			try {
				this.port = await navigator.serial.requestPort();
				console.log('USB-COM open.');
                beginlog('USB-COM open.');
				await this.port.open({baudRate: 115200});
				this.writer = this.port.writable.getWriter();
		        this.reader = this.port.readable.getReader();
				if (typeof init_cb == 'function') init_cb(this.port);
			}
			catch (err) {
				console.error('There was an error opening the serial port:', err);
			}
		}
		else {
			console.error('Web serial doesn\'t seem to be enabled in your browser. Try enabling it by visiting:');
			console.error('chrome://flags/#enable-experimental-web-platform-features');
			console.error('opera://flags/#enable-experimental-web-platform-features');
			console.error('edge://flags/#enable-experimental-web-platform-features');
			alert('Web serial doesn\'t seem to be enabled in your browser. Try enabling it by visiting:\r\nchrome://flags/#enable-experimental-web-platform-features\r\nopera://flags/#enable-experimental-web-platform-features\r\nedge://flags/#enable-experimental-web-platform-features');
			// chrome://device-log
		}
	}
	async write_raw(data) {
		return await this.writer.write(data);
	}
	async read_raw_all(add_data_cb) {
		try {
	        // this.reader = this.port.readable.getReader();
			while (true) {
				const { value, done } = await this.reader.read();
				if (done) {
					 console.log('|reader| has been canceled.');
			        break;
				}
				// Do something with |value|...
                //console.log('RX {' + value + '}');
				if (typeof add_data_cb == 'function') add_data_cb(value);
			}
		}
		catch (err) {
			console.error('Error reading data:', err);
            beginlog('Error reading data:', err);
		}
	}
	async close() {
		await this.writer.close();
		await this.reader.cancel();
		await this.port.close();
		console.log('USB-COM close.');
	}
}
var serialController = new SerialController();
const connect = $('butOpen');
async function DeviceStart() {
	connect.innerText = 'Close';
    
	blk = new Uint8Array(); // flush RX
	serialController.read_raw_all(DeviceRead);

	console.log('GetVersion...');
    wake_build_packet(CMD_GETVER, new Uint8Array([0x00]), 1);
	serialController.write_raw(new Uint8Array(wake_out_buf));
	await delay(50);
}
async function DeviceStop() {
	serialController.close();
}
connect.addEventListener("click", () => {
	if(connect.innerText == 'Close') {
		DeviceStop();
		connect.innerText = 'Open';
	} else {
		serialController.init(DeviceStart);
	}
});


// чтение из UART
var blk;
var freq = 0 ;
var fftByteArray = new Uint16Array(4096);
var fftIndex ;
var rawdataByteArray = new Int16Array(4096);
var rawdataIndex ;

function DeviceRead(data) {
	var parse_status ;
    //console.log("DeviceRead Rx_Sta=" + Rx_Sta + ", Rx_Nbt=" + Rx_Nbt + " new data :" + data);
	for (var ii=0; ii<data.length; ii++) {
	 parse_status = parser_wake(data[ii]);
	 
	 if (parse_status == RX_CRC_ERR) {
      Rx_Sta = WAIT_START_AA;
      data = [] ;
      return ;
      } else 
	 if (parse_status == RX_DONE) {
	  //console.log("[RX_DONE] CMD=" + Rx_Cmd, " DATA:", Rx_Dat);
      Rx_Sta = WAIT_START_AA;
	  
	  if(1) {
		//beginlog("parse ");
           {
            if(Rx_Cmd == CMD_GETVER){
                var s = "";
                for (var i = 0; i < Rx_Dat.length; i++) {s += String.fromCharCode(Rx_Dat[i]);}
                beginlog(s);
            } else 
            if( (Rx_Cmd == CMD_READ_MEM_U8) || (Rx_Cmd == CMD_READ_MEM_U32) ) {
                var read_addr = ((Rx_Dat[3] << 24) + (Rx_Dat[2] << 16) + (Rx_Dat[1] << 8) + Rx_Dat[0]) ; ;
                var read_items = Rx_Dat[4] ; ;
                Rx_Dat = Rx_Dat.slice(5) ;
                var s = "";
                if(Rx_Cmd == CMD_READ_MEM_U8) { 
                    for (var i = 0; i < Rx_Dat.length; i++) {s += Rx_Dat[i].toString(16).padStart(2, '0').toUpperCase() + ' ' ;}
                } else {
                    var u32_val = new Uint32Array(1) ;
                    for (var i = 0; i < Rx_Dat.length/4; i++) {
                        u32_val[0] = (((Rx_Dat[4*i+3] << 24) + (Rx_Dat[4*i+2] << 16) + (Rx_Dat[4*i+1] << 8) + Rx_Dat[4*i+0])) ; 
                        s += u32_val[0].toString(16).padStart(8, '0').toUpperCase() + ' ' ;}
                }
                $('input_data').value = s ;
                beginlog("read_u8  [0x" + read_addr.toString(16) + '] (' + read_items + ') {' + s + '}', 'out');
            } else 
            if(Rx_Cmd == CMD_COLLECTED_DATA){
              collected_data = Rx_Dat ;
              bufRawData = Uint8Array.from(Rx_Dat);
              
              collected_mask = collected_data[0] ; 
              collected_points = ((collected_data[2] << 8) + collected_data[1]) ;
              collected_data = collected_data.slice(3) ;
              
              if(collected_mask & (1<<0)) { $('chmask0').checked = true ;} else { $('chmask0').checked = false ; }
              if(collected_mask & (1<<1)) { $('chmask1').checked = true ;} else { $('chmask1').checked = false ; }
              if(collected_mask & (1<<2)) { $('chmask2').checked = true ;} else { $('chmask2').checked = false ; }
              if(collected_mask & (1<<3)) { $('chmask3').checked = true ;} else { $('chmask3').checked = false ; }
              if(collected_mask & (1<<4)) { $('chmask4').checked = true ;} else { $('chmask4').checked = false ; }
              if(collected_mask & (1<<5)) { $('chmask5').checked = true ;} else { $('chmask5').checked = false ; }
              if(collected_mask & (1<<6)) { $('chmask6').checked = true ;} else { $('chmask6').checked = false ; }
              
              var str = 'collected_data (0x' + collected_mask.toString(16) + ')   [' + collected_points + ']' ;
              beginlog(str);
              
              SetСhSel(0) ;
            }
        } // no ACK
	  }
	  
	  Rx_Dat = [] ;
	 }
	}
}


var read_write_addr = 0 ;
var read_write_n_items = 0 ;
var read_write_data = new Uint32Array() ;
function parse_input_fields(u8_u32_data_select) {
    read_write_addr = $('input_addr').value ;
    read_write_addr = parseInt(read_write_addr, 16)
    $('input_addr').value = '0x' + read_write_addr.toString(16).toUpperCase() ;

    read_write_n_items = $('input_n').value ;
    read_write_n_items = parseInt(read_write_n_items, 10) ;
    $('input_n').value = read_write_n_items.toString(10) ;

    $('input_data').value.match(/[^\/]+/g);
    read_write_data = $('input_data').value.split(" ").filter(Boolean).map(function (x) { return parseInt(x, 16); });
    console.log(read_write_data, read_write_data.length);
    var s = "";
    for (var i = 0; i < read_write_data.length; i++) {
        if(u8_u32_data_select == 0) {
            s += (read_write_data[i] & 0xFF).toString(16).padStart(2, '0').toUpperCase() + ' ' ;
        } else {
            s += (read_write_data[i] & 0xFFFFFFFF).toString(16).padStart(8, '0').toUpperCase() + ' ' ;
        }
    }
    $('input_data').value = s ;
}

$('read_u8_Btn').addEventListener('click', function() {
  parse_input_fields(0);
  beginlog("read_u8  [0x" + read_write_addr.toString(16) + '] (' + read_write_n_items + ') {' + read_write_data + '}', 'out');
  wake_build_packet(CMD_READ_MEM_U8, new Uint8Array([read_write_addr, read_write_addr >> 8, read_write_addr >> 16, read_write_addr >> 24, read_write_n_items], ), 5);
  serialController.write_raw(new Uint8Array(wake_out_buf));
});

$('read_u32_Btn').addEventListener('click', function() {
  parse_input_fields(1);
  beginlog("read_u32  [0x" + read_write_addr.toString(16) + '] (' + read_write_n_items + ') {' + read_write_data + '}', 'out');
  wake_build_packet(CMD_READ_MEM_U32, new Uint8Array([read_write_addr, read_write_addr >> 8, read_write_addr >> 16, read_write_addr >> 24, read_write_n_items], ), 5);
  serialController.write_raw(new Uint8Array(wake_out_buf));
});

$('write_u8_Btn').addEventListener('click', function() {
  parse_input_fields(0);
  var new_data = Uint8Array.from(read_write_data);
  beginlog("write_u8  [0x" + read_write_addr.toString(16) + '] (' + read_write_n_items + ') {' + new_data + '}', 'out');
  wake_build_packet(CMD_WRITE_MEM_U8, new Uint8Array([read_write_addr, read_write_addr >> 8, read_write_addr >> 16, read_write_addr >> 24, read_write_n_items, ...new_data]), 5+new_data.length);
  serialController.write_raw(new Uint8Array(wake_out_buf));
});

$('write_u32_Btn').addEventListener('click', function() {
  parse_input_fields(1);
  var new_data = new Uint8Array(4*read_write_data.length);
  for (var i = 0; i < read_write_data.length; i++) {
    new_data[4*i+0] = read_write_data[i] ;
    new_data[4*i+1] = read_write_data[i] >> 8 ;
    new_data[4*i+2] = read_write_data[i] >> 16 ;
    new_data[4*i+3] = read_write_data[i] >> 24 ;
  }
  beginlog("write_u32  [0x" + read_write_addr.toString(16) + '] (' + read_write_n_items + ') {' + new_data + '}', 'out');
  wake_build_packet(CMD_WRITE_MEM_U32, new Uint8Array([read_write_addr, read_write_addr >> 8, read_write_addr >> 16, read_write_addr >> 24, read_write_n_items, ...new_data] ), 5+new_data.length);
  serialController.write_raw(new Uint8Array(wake_out_buf));
});

$('read_data').addEventListener('click', function() {
    $('input_addr').value = "0x4001B000" ;
    $('input_n').value = "7" ;
    $('read_u32_Btn').click()
});

$('read_angle').addEventListener('click', function() {
    $('input_addr').value = "0x4001B09C" ;
    $('input_n').value = "7" ;
    $('read_u32_Btn').click()
});


$('read_gain').addEventListener('click', function() {
    $('input_addr').value = "0x4001C07C" ;
    $('input_n').value = "1" ;
    $('read_u32_Btn').click()
});

$('write_gain_0').addEventListener('click', function() {
    $('input_addr').value = "0x4001C07C" ;
    $('input_n').value = "1" ;
    $('input_data').value = "0" ;
    $('write_u32_Btn').click()
});

$('write_gain_8').addEventListener('click', function() {
    $('input_addr').value = "0x4001C07C" ;
    $('input_n').value = "1" ;
    $('input_data').value = "3FFF" ;
    $('write_u32_Btn').click()
});

$('write_current_gain_8').addEventListener('click', function() {
    $('input_addr').value = "0x4001C07C" ;
    $('input_n').value = "1" ;
    $('input_data').value = "FF" ;
    $('write_u32_Btn').click()
});




$('clrBtn').addEventListener('click', function() {
  $('terminal').innerHTML = "";
  datau = [] ; showDataIndex = 0 ;
  ShowGrf();
});


$('defaultAdcSelBtn').addEventListener('click', function() {
	var send_byte = 0x00 ;
    wake_build_packet(CMD_SETMODE,  new Uint8Array([send_byte]), 1);
	serialController.write_raw(new Uint8Array(wake_out_buf));
});

$('AdcDataSelBtn').addEventListener('click', function() {
	var send_byte = 0x81 ;
    wake_build_packet(CMD_SETMODE,  new Uint8Array([send_byte]), 1);
	serialController.write_raw(new Uint8Array(wake_out_buf));
});

$('EmulDataSelBtn').addEventListener('click', function() {
	var send_byte = 0x82 ;
    wake_build_packet(CMD_SETMODE,  new Uint8Array([send_byte]), 1);
	serialController.write_raw(new Uint8Array(wake_out_buf));
});

$('AaDataSelBtn').addEventListener('click', function() {
	var send_byte = 0x83 ;
    wake_build_packet(CMD_SETMODE,  new Uint8Array([send_byte]), 1);
	serialController.write_raw(new Uint8Array(wake_out_buf));
});

$('getVerBtn').addEventListener('click', function() {
    wake_build_packet( CMD_GETVER, new Uint8Array([0x00]), 1);
	serialController.write_raw(new Uint8Array(wake_out_buf));
});

$('startCollectionBtn').addEventListener('click', function() {
    wake_build_packet( CMD_START_COLLECT, new Uint8Array([0x40]), 1);
	serialController.write_raw(new Uint8Array(wake_out_buf));
});

$('startCycleCollectionBtn').addEventListener('click', function() {
    wake_build_packet( CMD_START_COLLECT, new Uint8Array([0xC0]), 1);
	serialController.write_raw(new Uint8Array(wake_out_buf));
});

$('setMaskBtn').addEventListener('click', function() {
    var send_byte = 0x00 ;
    if( $('chmask0').checked ) { send_byte |= 1<<0 ; }
    if( $('chmask1').checked ) { send_byte |= 1<<1 ; }
    if( $('chmask2').checked ) { send_byte |= 1<<2 ; }
    if( $('chmask3').checked ) { send_byte |= 1<<3 ; }
    if( $('chmask4').checked ) { send_byte |= 1<<4 ; }
    if( $('chmask5').checked ) { send_byte |= 1<<5 ; }
    if( $('chmask6').checked ) { send_byte |= 1<<6 ; }
    wake_build_packet( CMD_SETMASK, new Uint8Array([send_byte]), 1);
	serialController.write_raw(new Uint8Array(wake_out_buf));
});

$('setMask2048Btn').addEventListener('click', function() {
    var send_byte = 0x00 ;
    if( $('chmask0').checked ) { send_byte |= 1<<0 ; }
    if( $('chmask1').checked ) { send_byte |= 1<<1 ; }
    if( $('chmask2').checked ) { send_byte |= 1<<2 ; }
    if( $('chmask3').checked ) { send_byte |= 1<<3 ; }
    if( $('chmask4').checked ) { send_byte |= 1<<4 ; }
    if( $('chmask5').checked ) { send_byte |= 1<<5 ; }
    if( $('chmask6').checked ) { send_byte |= 1<<6 ; }
    var need_points = 2048 ;
    wake_build_packet( CMD_SETMASK, new Uint8Array([send_byte, need_points & 0xFF, (need_points >> 8) & 0xFF]), 3);
	serialController.write_raw(new Uint8Array(wake_out_buf));
});

$('SaveBtn').addEventListener('click', function() {
  log('fftsave to csv');
  var csv = convertArrayOfObjectsToCSV({data: datau});
  if (!csv.match(/^data:text\/csv/i)) {csv = 'data:text/csv;charset=utf-8,' + csv;}
  var encodedUri = encodeURI(csv);
  var link = document.createElement('a');
  link.setAttribute('href', encodedUri);
  link.setAttribute('download',devicename.replace("#","")+"_"+".csv");
  link.click();
});

function download(bytes, fname)  {
  //debugger;
  let blob = new Blob([bytes], {type:"application/octet-stream"});
  let link = document.createElement('a');
  link.href = window.URL.createObjectURL(blob);
  link.download = fname;
  link.click();
}
  
var bufRawData = new Int8Array();
$("butBufSave").onclick =  function() {
    console.log(bufRawData);
    download(bufRawData, "logger3byteData.bin"); 
}

var openFile = function(event) {
  var input = event.target;

  var reader = new FileReader();
  reader.onload = function() {
              //collected_data = Uint8Array.from(reader.result);
              collected_data = new Uint8Array(reader.result);
              console.log(collected_data);
              
              bufRawData = Uint8Array.from(collected_data);
              
              collected_mask = collected_data[0] ; 
              collected_points = ((collected_data[2] << 8) + collected_data[1]) ;
              collected_data = collected_data.slice(3) ;
              
              if(collected_mask & (1<<0)) { $('chmask0').checked = true ;} else { $('chmask0').checked = false ; }
              if(collected_mask & (1<<1)) { $('chmask1').checked = true ;} else { $('chmask1').checked = false ; }
              if(collected_mask & (1<<2)) { $('chmask2').checked = true ;} else { $('chmask2').checked = false ; }
              if(collected_mask & (1<<3)) { $('chmask3').checked = true ;} else { $('chmask3').checked = false ; }
              if(collected_mask & (1<<4)) { $('chmask4').checked = true ;} else { $('chmask4').checked = false ; }
              if(collected_mask & (1<<5)) { $('chmask5').checked = true ;} else { $('chmask5').checked = false ; }
              if(collected_mask & (1<<6)) { $('chmask6').checked = true ;} else { $('chmask6').checked = false ; }
              
              var str = 'collected_data (0x' + collected_mask.toString(16) + ')   [' + collected_points + ']' ;
              beginlog(str);
              
              SetСhSel(0) ;
  };
  reader.readAsArrayBuffer(input.files[0]);
};

function convertArrayOfObjectsToCSV(value){
	var result, ctr, keys, columnDelimiter, lineDelimiter, data;

	data = value.data || null;
	if (data == null || !data.length) {return null;}
	columnDelimiter = value.columnDelimiter || ';';
	lineDelimiter = value.lineDelimiter || '\n';
	keys = Object.keys(data[1]);
	result = '';

	data.forEach(function(item){
		ctr = 0;
		keys.forEach(function(key){
			if (ctr > 0)
				result += columnDelimiter;
			result += item[key].toFixed(3).replace(".",",");
			ctr++;
		});
		result += lineDelimiter;
	});
	return result;
}


//-------------------------------------------------------------------
// отображение графика
var stg = 0;
var datau = [];
var graphDiv = $('div_v') ;
var graphLab = $('labdiv');
var grapTitle = 'ADC data' ;

function ShowGrf() {
	if(!stg) {
		const gu = new Dygraph(
			graphDiv,
		    datau, 
              {
				title: grapTitle ,
				showRangeSelector: true, //true,
				//showRoller: true, //true,
				xlabel: 'n_point',
				ylabel: 'code',
				labels: graph_labels,
				labelsDiv: graphLab,
				legend: "follow", //'always',  // "follow"
				//digitsAfterDecimal: 3,
				//colors: ['green'],
				//axes: { x: {valueFormatter: function(x){return this.getLabels()[0] + ': '+ x.toPrecision(5);}}},
              }
            );
//		setInterval(function(){renderChart()}, 50);
		stg = 0;
	} else {
		gu.updateOptions({'file': datau});
	}
}

//-----------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------
//WAKE
//-----------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------
const COMM_ADDR_MASTER   = 0x7F; // получатель - мастер линии, ПК или центральный контроллер
const COMM_ADDR_SLAVE    = 0x00; // получатель - все

//стандартные
const CMD_NOP         = 0x00 ; // Нет операции
const CMD_ERR         = 0x01 ; // Передача кода ошибки
const CMD_ECHO        = 0x02 ; // Запрос возврата переданного пакета
const CMD_INFO        = 0x03 ; // Запрос информации об устройстве
const CMD_SETADDR     = 0x04 ; // Установка адреса устройства
const CMD_GETADDR     = 0x05 ; // Чтение адреса устройства
const CMD_GETVER      = 0x10 ; // Чтение адреса устройства
//пользовательские
const CMD_SETMODE     = 0x06 ; // Установка режима работы
const CMD_GETMODE     = 0x07 ; // Чтение режима работы
const CMD_SETMASK     = 0x08 ; // Установка маски

const CMD_READ_MEM_U8   = 0x20 ; // Чтение из памяти/регистров
const CMD_READ_MEM_U32  = 0x21 ; // Чтение из памяти/регистров
const CMD_WRITE_MEM_U8  = 0x22 ; // Запись в память/регистры
const CMD_WRITE_MEM_U32 = 0x23 ; // Запись в память/регистры

const CMD_START_COLLECT    = 0xAA ; // Запуск измерения
const CMD_COLLECTED_DATA   = 0xBB ; // Накопленные данные измерения

const CMD_ANALOG_DATA = 0x08 ; // Передача данных
const CMD_RAW_DATA    = 0x09 ; // Передача сырых данных
const CMD_DIO_DATA    = 0x0A ; // состояние входов
const CMD_FW_UPDATE   = 0x10 ; // обновление ПО по UART




const  START_BYTE_AA  = 0xAA ;
const  START_BYTE_F1  = 0xF1 ;
const  CRC_INIT  = 0xDE ;   //Innitial CRC value

var wake_out_buf = [] ; // new Uint8Array() ; // [] ;

//--------------------- Вычисление контрольной суммы: ------------------------
function Do_Crc8(b, crc)
{
 crc = (crc + b) & 0xFF ;
/*
  for(var i = 0; i < 8; b = b >> 1, i++)
    if((b ^ crc) & 1) crc = ((crc ^ 0x18) >> 1) | 0x80;
     else crc = (crc >> 1) & ~0x80;
*/     
  return crc ;
}


// фомирование пакета для передачи
// на выходе wake_out_buf
// использование
// wake_build_packet(0x0F, new Uint8Array([0x53, 0x54, 0x41, 0x52, 0x54]), 0x05);
// serialController.write_raw(new Uint8Array(wake_out_buf));
function wake_build_packet(_cmd, _in_data, _n_bytes)
{
 var out_bytes = 0 ;
 var wake_byte = 0 ;

 //beginlog('SEND, (' + _cmd.toString(16)+') ' + _in_data.toString(16));
 
 wake_out_buf = wake_out_buf.slice(0, 0) ;
 
 var _crc = CRC_INIT ;
 
 _crc = Do_Crc8(START_BYTE_AA, _crc);
 _crc = Do_Crc8(START_BYTE_F1, _crc);
 _crc = Do_Crc8(_cmd, _crc);
 _crc = Do_Crc8(_n_bytes & 0xFF, _crc);
 _crc = Do_Crc8((_n_bytes >> 8) & 0xFF, _crc);
 for(var _i=0; _i<_n_bytes; _i++) {
      _crc = Do_Crc8(_in_data[_i], _crc);
  }
 
 wake_out_buf.push(START_BYTE_AA);
 wake_out_buf.push(START_BYTE_F1);
 wake_out_buf.push(_cmd);
 
 wake_out_buf.push(_n_bytes);
 wake_out_buf.push(_n_bytes >> 8);
 
 for(var _i=0; _i<_n_bytes; _i++) {
	 wake_out_buf.push(_in_data[_i]);
 }
 
 wake_out_buf.push(_crc);
 
 console.log('WAKE outdata', wake_out_buf);
}


//RX process states:
const  WAIT_START_AA = 0 ; //ожидание приема 
const  WAIT_START_F1 = 1 ; //ожидание приема 
const  WAIT_CMD  = 2 ; //ожидание приема команды
const  WAIT_NBT_L  = 3 ; //ожидание приема количества байт в пакете
const  WAIT_NBT_H  = 4 ; //ожидание приема количества байт в пакете
const  WAIT_DATA = 5 ; //прием данных
const  WAIT_CRC  = 6 ; //ожидание окончания приема CRC
const  RX_DONE   = 7 ; //успешно принят новый пакет
const  RX_CRC_ERR   = 8 ; //

// переменые для приёма
var  Rx_Sta = WAIT_START_AA,        //состояние процесса приема пакета
     Rx_Cmd,        //принятая команда
     Rx_Nbt,        //принятое количество байт в пакете
     Rx_Dat = [],   //массив принятых данных
     Rx_Crc,        //контрольная сумма принимаемого пакета
     Rx_Ptr;        //указатель на массив принимаемых данных

// WAKE приём, побайтово
function parser_wake(data_byte)
{
//console.log('parser_wake :',"data_byte",data_byte, "Rx_Sta",Rx_Sta, "Rx_Nbt", Rx_Nbt, "Rx_Ptr",Rx_Ptr, "Rx_Crc", Rx_Crc);
  switch(Rx_Sta)
  {
  case WAIT_START_AA:                     //-----> ожидание начала фрейма
    {
      if(data_byte == START_BYTE_AA)               //если обнаружено начало фрейма,
      {
        Rx_Crc = CRC_INIT;                //инициализация CRC,
        Rx_Crc = Do_Crc8(data_byte, Rx_Crc);      //обновление CRC,
        Rx_Sta = WAIT_START_F1;               //сброс указателя данных,
      }
    }
  break;
  
  case WAIT_START_F1:                     //-----> ожидание начала фрейма
    {
      if(data_byte == START_BYTE_F1)               //если обнаружено начало фрейма,
      {
        Rx_Crc = Do_Crc8(data_byte, Rx_Crc);      //обновление CRC,
        Rx_Sta = WAIT_CMD;               //сброс указателя данных,
      } else if(data_byte != START_BYTE_AA) {
        Rx_Sta = WAIT_START_AA;
      }
    }
  break;
  
  case WAIT_CMD:                      //-----> ожидание приема команды
    {
      Rx_Cmd = data_byte;             //сохранение команды
      Rx_Crc = Do_Crc8(data_byte, Rx_Crc);    //обновление CRC
      Rx_Sta = WAIT_NBT_L;              //переходим к приему количества байт
    }
  break;
  
  case WAIT_NBT_L:                      //-----> ожидание приема количества байт
    {
      Rx_Nbt = data_byte;
      Rx_Crc = Do_Crc8(data_byte, Rx_Crc);    //обновление CRC
      Rx_Ptr = 0;                     //обнуляем указатель данных
      Rx_Sta = WAIT_NBT_H;             //переходим к приему данных
    }
  break;

  case WAIT_NBT_H:                      //-----> ожидание приема количества байт
    {
      Rx_Nbt += (data_byte << 8);
      Rx_Crc = Do_Crc8(data_byte, Rx_Crc);    //обновление CRC
      Rx_Ptr = 0;                     //обнуляем указатель данных
      Rx_Sta = WAIT_DATA;             //переходим к приему данных
      //console.log('parser_wake, Rx_Nbt=', Rx_Nbt);
    }
  break;
  
  case WAIT_DATA:                     //-----> ожидание приема данных
    {
      if(Rx_Ptr < Rx_Nbt)             //если не все данные приняты,
      {
        Rx_Dat[Rx_Ptr++] = data_byte; //то сохранение байта данных,
        Rx_Crc = Do_Crc8(data_byte, Rx_Crc);  //обновление CRC
        break;
      }
      if(data_byte != Rx_Crc)         //если приняты все данные, то проверка CRC
      {
        console.log('parser_wake, error CRC ', data_byte, Rx_Crc, 'CMD', Rx_Cmd, 'Nbt', Rx_Nbt);
        Rx_Sta = RX_CRC_ERR ; //WAIT_START_AA;           //если CRC не совпадает,
        break;
      }
      //console.log('parser_wake, ok CRC ', data_byte, Rx_Crc);
      Rx_Sta = RX_DONE ;             //прием пакета завершен,
      break;
    }
  }

  return(Rx_Sta);
}

</script>

</html>
