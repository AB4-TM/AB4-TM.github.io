<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <link href="styles.css" rel="stylesheet">
	<title>HT7627 UART</title>
	<script type="text/javascript" src="dygraph.min.js"></script>
	<script type="text/javascript" src="fft.js"></script>
</head>
<body>

<p>
  <button id="clrBtn" type="button">CLEAR</button>
  <button id="butOpen" type="button">Open</button>
  <button id="SaveBtn" type="button">SAVE GRAPH TO CSV</button>
  <button id="butBufSave" type="button">Save buf.bin</button>
  read from file <input type='file' accept='.bin' onchange='openFile(event)'><br>
</p>
  <button id="getVerBtn" type="button">GET VER</button>
  <button id="startCollectionBtn" type="button">START COLLECTION</button>
  <button id="startCycleCollectionBtn" type="button">START CYCLE COLLECTION</button>
  <button id="rebootCmdBtn" type="button">CMD reboot</button>
</p>
  <input type="checkbox" id="chmask6" name="chmask6" >
  <input type="checkbox" id="chmask5" name="chmask5" checked>
  <input type="checkbox" id="chmask4" name="chmask4" checked>
  <input type="checkbox" id="chmask3" name="chmask3" checked>
  <input type="checkbox" id="chmask2" name="chmask2" checked>
  <input type="checkbox" id="chmask1" name="chmask1" checked>
  <input type="checkbox" id="chmask0" name="chmask0" checked>
  <button id="setMaskBtn" type="button">set mask</button>
  <button id="setMask2048Btn" type="button">set mask 2048</button>
  <button id="setMaskAndRegBtn" type="button">set mask+REG data</button>
  <input type="checkbox" name="radio_set" id="checkboxFft">FFT</input>  
  <br>
  <input type="checkbox" name="radio_set_7" id="checkbox7" onclick="SetСhSel(6)" >In</input>
  <input type="checkbox" name="radio_set_6" id="checkbox6" onclick="SetСhSel(5)" >Ic</input>
  <input type="checkbox" name="radio_set_5" id="checkbox5" onclick="SetСhSel(4)" >Ib</input>
  <input type="checkbox" name="radio_set_4" id="checkbox4" onclick="SetСhSel(3)" >Ia</input>
  <input type="checkbox" name="radio_set_3" id="checkbox3" onclick="SetСhSel(2)" >Uc</input>
  <input type="checkbox" name="radio_set_2" id="checkbox2" onclick="SetСhSel(1)" >Ub</input>
  <input type="checkbox" name="radio_set_1" id="checkbox1" onclick="SetСhSel(0)" checked>Ua</input>
</p>
<details>
    <summary>template</summary>
      <button id="read_data" type="button">EMU read data</button>
      <button id="read_angle" type="button">EMU read angle</button>
      <button id="read_signal_status" type="button">EMU read signal status</button>
    <br>  
      <button id="read_d_gain" type="button">EMU read d_gain</button>
      <button id="write_d_gain_0" type="button">EMU set d_gain 0</button>
      <button id="write_d_gain_8" type="button">EMU set d_gain 8</button>
    <br>  
      <button id="read_a_gain" type="button">EMU read a_gain</button>
      <button id="write_a_gain_0" type="button">EMU set a_gain 0</button>
      <button id="write_a_gain_max" type="button">EMU set a_gain max</button>
    <br>  
      <button id="read_calibr" type="button">FLASH read calibr</button>
      <button id="write_calibr" type="button">FLASH write calibr</button>
      <button id="read_sn" type="button">INFO FLASH read SN</button>
    <br>  
      <button id="read_calibration_Btn" type="button">read calibration</button>

</details>
</p>
  <input id="input_addr" type="text" size="10" value="0x4001B000">
  <input id="input_n" type="text" size="2" value="16">
  <input id="input_data" type="text" size="35" value="CA FE">
  <button id="read_u32_Btn" type="button">read u32</button>
  <button id="write_u32_Btn" type="button">write u32</button>
  <button id="read_u8_Btn" type="button">read u8</button>
  <button id="write_u8_Btn" type="button">write u8</button>
</p>
<details>
  <summary>calibration</summary>
      <input type="checkbox" id="scale_sel" name="scale_sel">SCALER</input>
      <input type="checkbox" id="filter_sel" name="filter_sel">50 Hz HPF</input>
      <input type="checkbox" name="use_hpf_check" id="use_hpf_check">internal HPF</input>
      <button id="calibr_set_cfg" type="button">set cfg</button>
      <button id="store_calibration_Btn" type="button">CMD store calibration</button>
      <br>  
      <b>------------ zero set ----------</b>
      <button id="autozero_Ua_Btn" type="button" onclick="calibrZero(0)" > Ua</button>
      <button id="autozero_Ub_Btn" type="button" onclick="calibrZero(1)" > Ub</button>
      <button id="autozero_Uc_Btn" type="button" onclick="calibrZero(2)" > Uc</button>
      <button id="autozero_Ia_Btn" type="button" onclick="calibrZero(3)" > Ia</button>
      <button id="autozero_Ib_Btn" type="button" onclick="calibrZero(4)" > Ib</button>
      <button id="autozero_Ic_Btn" type="button" onclick="calibrZero(5)" > Ic</button>
      <br>
      <b>correct gain, %</b>
      <input id="input_err_percent" type="text"  size="5" value="0" style="text-align:right";>
      <button id="gain_Ua_Btn" type="button" onclick="calibrGain(0)" > Ua</button>
      <button id="gain_Ub_Btn" type="button" onclick="calibrGain(1)" > Ub</button>
      <button id="gain_Uc_Btn" type="button" onclick="calibrGain(2)" > Uc</button>
      <button id="gain_Ia_Btn" type="button" onclick="calibrGain(3)" > Ia</button>
      <button id="gain_Ib_Btn" type="button" onclick="calibrGain(4)" > Ib</button>
      <button id="gain_Ic_Btn" type="button" onclick="calibrGain(5)" > Ic</button>
      <br>  
      <b>correct phase, °</b>
      <input id="input_phase_err_angke" type="text"  size="5" value="0" style="text-align:right";>
      <button id="phase_Ua_Btn" type="button" onclick="calibrPhase(0)" > Ua</button>
      <button id="phase_Ub_Btn" type="button" onclick="calibrPhase(1)" > Ub</button>
      <button id="phase_Uc_Btn" type="button" onclick="calibrPhase(2)" > Uc</button>
      <button id="phase_Ia_Btn" type="button" onclick="calibrPhase(3)" > Ia</button>
      <button id="phase_Ib_Btn" type="button" onclick="calibrPhase(4)" > Ib</button>
      <button id="phase_Ic_Btn" type="button" onclick="calibrPhase(5)" > Ic</button>
</details>
</p>

<div style="height: auto; width: auto; text-align: center;">
<div id="div_v"	style="height:400px;"></div>
<div id='labdiv' style=></div>

<div style="height: auto; width: auto; text-align: left; overflow: auto;">
<div id="terminal">
	<div>Версия V0.0.2</div>
</div>

</body>


<script type="text/javascript">
"use strict";

var devicename = "#0" ;
var showDataIndex = 0 ;


function log(data, type = '') {
  $('terminal').insertAdjacentHTML('beforeend',
      '<div' + (type ? ' class="' + type + '"' : '') + '>' + data + '</div>');
}
function beginlog(data, type = '') {
  $('terminal').insertAdjacentHTML('afterbegin',
      '<div' + (type ? ' class="' + type + '"' : '') + '>' + data + '</div>');
}
var $ = function(id) {
	return document.getElementById(id);
}
function delay(ms) {
  return new Promise((resolve, reject) => {
	setTimeout(resolve, ms);
  });
}
function hex(number, length) {
	var str = (number.toString(16)).toUpperCase();
	while (str.length < length) str = '0' + str;
	return str;
}

function dec2bin(dec) {
  return (dec >>> 0).toString(2);
}

var summ_data = new Array(7) ;
var middle_data = new Int32Array(7) ;

var collected_data = [] ;
var collected_mask ;
var collected_points ;
var ch_in_use = 0 ;
var graph_labels = [] ;

const BYTES_IN_ONE_CHANNEL_DATA = 3 ;
function SetСhSel(ch_sel) {
    if(ch_sel != -1) { stg = 0 ; }
    ch_in_use = 0 ;
    if( collected_mask & (1<<0) ) { ch_in_use++; }
    if( collected_mask & (1<<1) ) { ch_in_use++; }
    if( collected_mask & (1<<2) ) { ch_in_use++; }
    if( collected_mask & (1<<3) ) { ch_in_use++; }
    if( collected_mask & (1<<4) ) { ch_in_use++; }
    if( collected_mask & (1<<5) ) { ch_in_use++; }
    if( collected_mask & (1<<6) ) { ch_in_use++; }
    
    for (var _ch=0; _ch<7; _ch++) { summ_data[_ch] = 0 ; }
    
    datau = [] ; showDataIndex = 0 ;
    for (var i=0; i<collected_points; i++) {
      var push_data = [showDataIndex++, ] ;
      var index_in_buf = i*BYTES_IN_ONE_CHANNEL_DATA*ch_in_use ;
      for (var _ch=0; _ch<7; _ch++) {
          if( collected_mask & (1<<_ch) ) { 
              var raw_3byte_value = ((collected_data[index_in_buf+2] << 16) + (collected_data[index_in_buf+1] << 8) + collected_data[index_in_buf+0]) ;
              index_in_buf += BYTES_IN_ONE_CHANNEL_DATA ;
              raw_3byte_value = raw_3byte_value >> 2 ;
              if(raw_3byte_value & (0x1 << 21)) { raw_3byte_value = -((0x1 << 21) - (raw_3byte_value & ~(0x1 << 21))) ; }
              summ_data[_ch] += raw_3byte_value ;
              
              if( (_ch == 0) && ($('checkbox1').checked) ) { push_data.push(raw_3byte_value);}
              if( (_ch == 1) && ($('checkbox2').checked) ) { push_data.push(raw_3byte_value);}
              if( (_ch == 2) && ($('checkbox3').checked) ) { push_data.push(raw_3byte_value);}
              if( (_ch == 3) && ($('checkbox4').checked) ) { push_data.push(raw_3byte_value);}
              if( (_ch == 4) && ($('checkbox5').checked) ) { push_data.push(raw_3byte_value);}
              if( (_ch == 5) && ($('checkbox6').checked) ) { push_data.push(raw_3byte_value);}
              if( (_ch == 6) && ($('checkbox7').checked) ) { push_data.push(raw_3byte_value);}
          }
      }
      
      graph_labels = ['num',] ;
      if( (collected_mask & (1<<0)) && ($('checkbox1').checked) ) { graph_labels.push('Ua');}
      if( (collected_mask & (1<<1)) && ($('checkbox2').checked) ) { graph_labels.push('Ub');}
      if( (collected_mask & (1<<2)) && ($('checkbox3').checked) ) { graph_labels.push('Uc');}
      if( (collected_mask & (1<<3)) && ($('checkbox4').checked) ) { graph_labels.push('Ia');}
      if( (collected_mask & (1<<4)) && ($('checkbox5').checked) ) { graph_labels.push('Ib');}
      if( (collected_mask & (1<<5)) && ($('checkbox6').checked) ) { graph_labels.push('Ic');}
      if( (collected_mask & (1<<6)) && ($('checkbox7').checked) ) { graph_labels.push('In');}
      //console.log("push_data", push_data);
      datau.push(push_data); 
    }

    for (var _ch=0; _ch<7; _ch++) { middle_data[_ch] = summ_data[_ch] / collected_points; }
    //console.log('middle_data', middle_data);
          
    grapTitle = 'ADC data' ;
    if(datau[0].length == 3) {
        console.log('\r\n----compare signals-----');
        var fft_1_input_data = [] ;
        var fft_2_input_data = [] ;
        for (var i=0; i<collected_points; i++) { fft_1_input_data.push(datau[i][1]); fft_2_input_data.push(datau[i][2]); }

        var average_value_1 = 0 ;
        var average_value_2 = 0 ;
        for (var i=0; i<collected_points; i++) { average_value_1 += fft_1_input_data[i]; average_value_2 += fft_2_input_data[i]; }
        average_value_1 /= collected_points ;
        average_value_2 /= collected_points ;
        for (var i=0; i<collected_points; i++) { fft_1_input_data[i] -= average_value_1; fft_2_input_data[i] -= average_value_2; }
        console.log('average_value', average_value_1.toFixed(0), average_value_2.toFixed(0));
        
        var rms_value_1 = 0 ;
        var rms_value_2 = 0 ;
        for (var i=0; i<collected_points; i++) { rms_value_1 += Math.pow(fft_1_input_data[i], 2) / collected_points; rms_value_2 += Math.pow(fft_2_input_data[i], 2) / collected_points; }
        rms_value_1 = Math.pow(rms_value_1, 0.5); 
        rms_value_2 = Math.pow(rms_value_2, 0.5); 
        console.log('rms_value', rms_value_1.toFixed(0), rms_value_2.toFixed(0), 'rms1/rms2', (rms_value_1 / rms_value_2).toFixed(5) );
        
        var fft_1_out = FFT(fft_1_input_data);
        var fft_2_out = FFT(fft_2_input_data);

        var fft_1_max_fft_data_value = 0 ;
        var fft_1_max_fft_data_index = 0 ;
        var fft_2_max_fft_data_value = 0 ;
        var fft_2_max_fft_data_index = 0 ;
        for (var i = 0; i < fft_1_input_data.length / 2; i += 1) {
          var X_abs_1 = Math.sqrt(fft_1_out[i].re * fft_1_out[i].re + fft_1_out[i].im * fft_1_out[i].im);
          var X_abs_2 = Math.sqrt(fft_2_out[i].re * fft_2_out[i].re + fft_2_out[i].im * fft_2_out[i].im);
		  if(fft_1_max_fft_data_value < X_abs_1) {fft_1_max_fft_data_value = X_abs_1; fft_1_max_fft_data_index = i;}
		  if(fft_2_max_fft_data_value < X_abs_2) {fft_2_max_fft_data_value = X_abs_2; fft_2_max_fft_data_index = i;}
		}
        var phase_1 = Math.atan(fft_1_out[fft_1_max_fft_data_index].im / fft_1_out[fft_1_max_fft_data_index].re);
        var phase_2 = Math.atan(fft_2_out[fft_1_max_fft_data_index].im / fft_2_out[fft_1_max_fft_data_index].re);
        
        var freq_step = 25600 / fft_1_input_data.length ;
		
        var angle = 180*(phase_2-phase_1)/3.1415296 ;
        if(angle >  90) { angle = 180 - angle ; }
        if(angle < -90) { angle = 180 + angle ; }
        
        grapTitle = 'freq ' + (freq_step*fft_1_max_fft_data_index).toFixed(2) + '  angle ' + angle.toFixed(3) ; 
        console.log('freq', (freq_step*fft_1_max_fft_data_index).toFixed(2), (freq_step*fft_2_max_fft_data_index).toFixed(2));
        console.log('phases', phase_1.toFixed(3), phase_2.toFixed(3), 'angle', angle.toFixed(3));
        console.log('fft',fft_1_max_fft_data_value.toFixed(2),fft_2_max_fft_data_value.toFixed(2), 'max1/max2', (fft_1_max_fft_data_value/fft_2_max_fft_data_value).toFixed(5));
        console.log('------------------------\r\n');
    }
    
    if($('checkboxFft').checked) {
        var fft_input_data = [] ;
        for (var i=0; i<collected_points; i++) { fft_input_data.push(datau[i][1]); }
        
        //console.log("datau", datau);
        //console.log("fft_input_data", fft_input_data);

        var fft_out = FFT(fft_input_data);
        var X_real = new Array(fft_input_data.length / 2).fill(0);
        var X_imag = new Array(fft_input_data.length / 2).fill(0);
        var X_abs = new Array(fft_input_data.length / 2).fill(0);

        datau = [] ;
        var freq_step = 25600 / fft_input_data.length ;
        for (var i = 0; i < fft_input_data.length / 2; i += 1) {
          X_real[i] = fft_out[i].re;
          X_imag[i] = fft_out[i].im;
          X_abs[i] = Math.sqrt(fft_out[i].re * fft_out[i].re + fft_out[i].im * fft_out[i].im);
          datau.push([i*freq_step, X_abs[i]]); 
        }    
        //console.log("X_abs", X_abs);
    }    
    
    ShowGrf();
}

function calibrGain(ch_sel) {
    var err_percent_value = $('input_err_percent').value ;
    err_percent_value = parseFloat(err_percent_value, 10) ;
    
    var send_value = new Int32Array(1);
    send_value[0] = err_percent_value * 1000 ;
    
    err_percent_value = send_value[0] ;
    err_percent_value /= 1000 ;
    beginlog('calibrGain: ' + ch_sel + ' ' + err_percent_value);
    
    wake_build_packet( CMD_CALIBR_GAIN, new Uint8Array([ch_sel, send_value[0] & 0xFF, (send_value[0] >> 8) & 0xFF, (send_value[0] >> 16) & 0xFF, (send_value[0] >> 24) & 0xFF]), 5);
    serialController.write_raw(new Uint8Array(wake_out_buf));
    
    var reg_addr = 0x4001C060 + 4*ch_sel ;
    
    $('input_addr').value = '0x' + reg_addr.toString(16).toUpperCase() ;
    $('input_n').value = 1 ;
}

function calibrZero(ch_sel) {
    var send_value = new Int32Array(1);
    send_value[0] = middle_data[ch_sel] ;
    wake_build_packet( CMD_CALIBR_SHIFT, new Uint8Array([ch_sel, send_value[0] & 0xFF, (send_value[0] >> 8) & 0xFF, (send_value[0] >> 16) & 0xFF, (send_value[0] >> 24) & 0xFF]), 5);
    serialController.write_raw(new Uint8Array(wake_out_buf));
    
    var reg_addr = 0x4001C038 + 4*ch_sel ;
    
    $('input_addr').value = '0x' + reg_addr.toString(16).toUpperCase() ;
    $('input_n').value = 1 ;
}


function calibrPhase(ch_sel) {
    var err_angle_value = $('input_phase_err_angke').value ;
    err_angle_value = parseFloat(err_angle_value, 10) ;
    
    var send_value = new Int32Array(1);
    send_value[0] = err_angle_value * 1000 ;
    
    err_angle_value = send_value[0] ;
    err_angle_value /= 1000 ;
    beginlog('calibrPhase: ' + ch_sel + ' ' + err_angle_value);
    
    wake_build_packet( CMD_CALIBR_PHASE, new Uint8Array([ch_sel, send_value[0] & 0xFF, (send_value[0] >> 8) & 0xFF, (send_value[0] >> 16) & 0xFF, (send_value[0] >> 24) & 0xFF]), 5);
    serialController.write_raw(new Uint8Array(wake_out_buf));
    
    var reg_addr = 0x4001C000 + 8*ch_sel ;
    
    $('input_addr').value = '0x' + reg_addr.toString(16).toUpperCase() ;
    $('input_n').value = 2 ;
}

class SerialController {
	async init(init_cb) {
		if ('serial' in navigator) {
			try {
				this.port = await navigator.serial.requestPort();
				console.log('USB-COM open.');
                beginlog('USB-COM open.');
				await this.port.open({baudRate: 115200});
				this.writer = this.port.writable.getWriter();
		        this.reader = this.port.readable.getReader();
				if (typeof init_cb == 'function') init_cb(this.port);
			}
			catch (err) {
				console.error('There was an error opening the serial port:', err);
			}
		}
		else {
			console.error('Web serial doesn\'t seem to be enabled in your browser. Try enabling it by visiting:');
			console.error('chrome://flags/#enable-experimental-web-platform-features');
			console.error('opera://flags/#enable-experimental-web-platform-features');
			console.error('edge://flags/#enable-experimental-web-platform-features');
			alert('Web serial doesn\'t seem to be enabled in your browser. Try enabling it by visiting:\r\nchrome://flags/#enable-experimental-web-platform-features\r\nopera://flags/#enable-experimental-web-platform-features\r\nedge://flags/#enable-experimental-web-platform-features');
			// chrome://device-log
		}
	}
	async write_raw(data) {
		return await this.writer.write(data);
	}
	async read_raw_all(add_data_cb) {
		try {
	        // this.reader = this.port.readable.getReader();
			while (true) {
				const { value, done } = await this.reader.read();
				if (done) {
					 console.log('|reader| has been canceled.');
			        break;
				}
				// Do something with |value|...
                //console.log('RX {' + value + '}');
				if (typeof add_data_cb == 'function') add_data_cb(value);
			}
		}
		catch (err) {
			console.error('Error reading data:', err);
            beginlog('Error reading data:', err);
		}
	}
	async close() {
		await this.writer.close();
		await this.reader.cancel();
		await this.port.close();
		console.log('USB-COM close.');
	}
}
var serialController = new SerialController();
const connect = $('butOpen');
async function DeviceStart() {
	connect.innerText = 'Close';
    
	blk = new Uint8Array(); // flush RX
	serialController.read_raw_all(DeviceRead);

	console.log('GetVersion...');
    wake_build_packet(CMD_GETVER, new Uint8Array([0x00]), 1);
	serialController.write_raw(new Uint8Array(wake_out_buf));
	await delay(50);
}
async function DeviceStop() {
	serialController.close();
}
connect.addEventListener("click", () => {
	if(connect.innerText == 'Close') {
		DeviceStop();
		connect.innerText = 'Open';
	} else {
		serialController.init(DeviceStart);
	}
});


// чтение из UART
var blk;
var freq = 0 ;
var fftByteArray = new Uint16Array(4096);
var fftIndex ;
var rawdataByteArray = new Int16Array(4096);
var rawdataIndex ;

function DeviceRead(data) {
	var parse_status ;
    //console.log("DeviceRead Rx_Sta=" + Rx_Sta + ", Rx_Nbt=" + Rx_Nbt + " new data :" + data);
	for (var ii=0; ii<data.length; ii++) {
	 parse_status = parser_wake(data[ii]);
	 
	 if (parse_status == RX_CRC_ERR) {
      Rx_Sta = WAIT_START_AA;
      data = [] ;
      return ;
      } else 
	 if (parse_status == RX_DONE) {
	  //if(Rx_Cmd != CMD_COLLECTED_DATA) {console.log("[RX_DONE] CMD=" + Rx_Cmd, " DATA:", Rx_Dat);}
      Rx_Sta = WAIT_START_AA;
	  
	  if(1) {
		//beginlog("parse ");
           {
            if(Rx_Cmd == CMD_GETVER){
                var s = "";
                for (var i = 0; i < Rx_Dat.length; i++) {s += String.fromCharCode(Rx_Dat[i]);}
                beginlog(s);
            } else 
            if( (Rx_Cmd == CMD_READ_MEM_U8) || (Rx_Cmd == CMD_READ_MEM_U32) || (Rx_Cmd == CMD_READ_CALIBRATION)  ) {
                var read_addr = ((Rx_Dat[3] << 24) + (Rx_Dat[2] << 16) + (Rx_Dat[1] << 8) + Rx_Dat[0]) ; ;
                var read_items = Rx_Dat[4] ; ;
                Rx_Dat = Rx_Dat.slice(5) ;
                var s = "";
                if((Rx_Cmd == CMD_READ_MEM_U8)  || (Rx_Cmd == CMD_READ_CALIBRATION)){ 
                    for (var i = 0; i < Rx_Dat.length; i++) {s += Rx_Dat[i].toString(16).padStart(2, '0').toUpperCase() + ' ' ;}
                } else {
                    var u32_val = new Uint32Array(1) ;
                    for (var i = 0; i < Rx_Dat.length/4; i++) {
                        u32_val[0] = (((Rx_Dat[4*i+3] << 24) + (Rx_Dat[4*i+2] << 16) + (Rx_Dat[4*i+1] << 8) + Rx_Dat[4*i+0])) ; 
                        s += u32_val[0].toString(16).padStart(8, '0').toUpperCase() + ' ' ;}
                }
                $('input_data').value = s ;
				
				if((Rx_Cmd == CMD_READ_MEM_U8)  || (Rx_Cmd == CMD_READ_CALIBRATION)){ 
					beginlog("read_u8  [0x" + read_addr.toString(16) + '] (' + read_items + ') {' + s + '}');
				} else {
					beginlog("read_u32  [0x" + read_addr.toString(16) + '] (' + read_items + ') {' + s + '}');
				}
                
                if(Rx_Cmd == CMD_READ_CALIBRATION) {
                    $('input_addr').value = '0x' + read_addr.toString(16).toUpperCase() ; 
                    $('input_n').value = read_items.toString(10) ;
                    if(Rx_Dat[4] & (1<<0)) {$('use_hpf_check').checked = true ;} else {$('use_hpf_check').checked = false ;}
                    if(Rx_Dat[4] & (1<<1)) {$('filter_sel').checked = true ;} else {$('filter_sel').checked = false ;}
                    if(Rx_Dat[4] & (1<<2)) {$('scale_sel').checked = true ;} else {$('scale_sel').checked = false ;}
                }
            } else 
            if(Rx_Cmd == CMD_COLLECTED_DATA){
              bufRawData = Uint8Array.from(Rx_Dat);
              
              parse_collected_data(Rx_Dat);
            }
        } // no ACK
	  }
	  
	  Rx_Dat = [] ;
	 }
	}
}

var cfg_serial_number = 0 ;
var cfg_analog_gain ;
var cfg_digital_gain ;
var cfg_hw_filter ;
var cfg_voltage_multiplier ;
var cfg_voltage_divider ;
var cfg_current_multiplier ;
var cfg_current_divider ;
var cfg_current_scale_multiplier ;
var cfg_current_scale_divider ;

function parse_collected_data(input_data)  {
              collected_data = input_data ;
              
              collected_mask = collected_data[0] ; 
              collected_points = ((collected_data[2] << 8) + collected_data[1]) ;
              collected_data = collected_data.slice(3) ;
              
              var ch_in_use = 0 ;
              if(collected_mask & (1<<0)) { $('chmask0').checked = true ; ch_in_use++; } else { $('chmask0').checked = false ; }
              if(collected_mask & (1<<1)) { $('chmask1').checked = true ; ch_in_use++; } else { $('chmask1').checked = false ; }
              if(collected_mask & (1<<2)) { $('chmask2').checked = true ; ch_in_use++; } else { $('chmask2').checked = false ; }
              if(collected_mask & (1<<3)) { $('chmask3').checked = true ; ch_in_use++; } else { $('chmask3').checked = false ; }
              if(collected_mask & (1<<4)) { $('chmask4').checked = true ; ch_in_use++; } else { $('chmask4').checked = false ; }
              if(collected_mask & (1<<5)) { $('chmask5').checked = true ; ch_in_use++; } else { $('chmask5').checked = false ; }
              if(collected_mask & (1<<6)) { $('chmask6').checked = true ; ch_in_use++; } else { $('chmask6').checked = false ; }
              
              var str = 'collected_data (0x' + collected_mask.toString(16) + ')   [' + collected_points + ']' ;
              var str1 = '' ;
              var str2 = '' ;
              
              var _shift_index = 0 ;
              var _config_data_index = collected_points*ch_in_use*BYTES_IN_ONE_CHANNEL_DATA ;
              var items_config_data = ((collected_data[_config_data_index+_shift_index+1] << 8) + collected_data[_config_data_index+_shift_index+0]) ; 
              _shift_index += 2 ;
              cfg_serial_number = ((collected_data[_config_data_index+_shift_index+3] << 24) + (collected_data[_config_data_index+_shift_index+2] << 16) + (collected_data[_config_data_index+_shift_index+1] << 8) + collected_data[_config_data_index+_shift_index+0]) ; 
              _shift_index += 4 ;
              cfg_analog_gain = ((collected_data[_config_data_index+_shift_index+1] << 8) + collected_data[_config_data_index+_shift_index+0]) ; 
              _shift_index += 2 ;
              cfg_digital_gain = ((collected_data[_config_data_index+_shift_index+1] << 8) + collected_data[_config_data_index+_shift_index+0]) ; 
              _shift_index += 2 ;
              cfg_hw_filter = ((collected_data[_config_data_index+_shift_index+3] << 24) + (collected_data[_config_data_index+_shift_index+2] << 16) + (collected_data[_config_data_index+_shift_index+1] << 8) + collected_data[_config_data_index+_shift_index+0]) ; 
              _shift_index += 4 ;
              cfg_voltage_multiplier  = ((collected_data[_config_data_index+_shift_index+3] << 24) + (collected_data[_config_data_index+_shift_index+2] << 16) + (collected_data[_config_data_index+_shift_index+1] << 8) + collected_data[_config_data_index+_shift_index+0]) ; 
              _shift_index += 4 ;
              cfg_voltage_divider  = ((collected_data[_config_data_index+_shift_index+3] << 24) + (collected_data[_config_data_index+_shift_index+2] << 16) + (collected_data[_config_data_index+_shift_index+1] << 8) + collected_data[_config_data_index+_shift_index+0]) ; 
              _shift_index += 4 ;
              cfg_current_multiplier  = ((collected_data[_config_data_index+_shift_index+3] << 24) + (collected_data[_config_data_index+_shift_index+2] << 16) + (collected_data[_config_data_index+_shift_index+1] << 8) + collected_data[_config_data_index+_shift_index+0]) ; 
              _shift_index += 4 ;
              cfg_current_divider  = ((collected_data[_config_data_index+_shift_index+3] << 24) + (collected_data[_config_data_index+_shift_index+2] << 16) + (collected_data[_config_data_index+_shift_index+1] << 8) + collected_data[_config_data_index+_shift_index+0]) ; 
              _shift_index += 4 ;
              cfg_current_scale_multiplier  = ((collected_data[_config_data_index+_shift_index+3] << 24) + (collected_data[_config_data_index+_shift_index+2] << 16) + (collected_data[_config_data_index+_shift_index+1] << 8) + collected_data[_config_data_index+_shift_index+0]) ; 
              _shift_index += 4 ;
              cfg_current_scale_divider  = ((collected_data[_config_data_index+_shift_index+3] << 24) + (collected_data[_config_data_index+_shift_index+2] << 16) + (collected_data[_config_data_index+_shift_index+1] << 8) + collected_data[_config_data_index+_shift_index+0]) ; 
              _shift_index += 4 ;
                
              str += ', cfg[' + items_config_data +  '](' + cfg_serial_number + ', 0x' + cfg_analog_gain.toString(16) + ', 0x' + cfg_digital_gain.toString(16) + ', 0x' + cfg_hw_filter.toString(16)  + ')' ;
              
              if(collected_data.length > (collected_points*ch_in_use*BYTES_IN_ONE_CHANNEL_DATA+2+items_config_data)) {
                var _index = collected_points*ch_in_use*BYTES_IN_ONE_CHANNEL_DATA + 2 + items_config_data;
                var addr_additional_data = new Uint32Array(1) ;
                var items_additional_data = new Uint32Array(1) ;
                addr_additional_data[0] = ((collected_data[_index+3] << 24) + (collected_data[_index+2] << 16) + (collected_data[_index+1] << 8) + collected_data[_index+0]) ; 
                items_additional_data[0] = ((collected_data[_index+5] << 8) + collected_data[_index+4]) ; 
                //console.log('additional_data', ch_in_use, _index, addr_additional_data[0].toString(16), items_additional_data[0]);
                
                str += 'add_data[' + addr_additional_data[0].toString(16) + '](' + items_additional_data[0] + ')' ;
                
                var rms_raw_values = new Uint32Array(7) ;
                var addr_Ua_rms = 0x4001B04C ;
                var _index_Ua = _index + 6 + (addr_Ua_rms - addr_additional_data[0])  ;
                //str += ', raw rms '
                for (var ch = 0; ch < 6; ch++) {
                    rms_raw_values[ch] = ((collected_data[4*ch+_index_Ua+3] << 24) + (collected_data[4*ch+_index_Ua+2] << 16) + (collected_data[4*ch+_index_Ua+1] << 8) + collected_data[4*ch+_index_Ua+0]) ; 
                    rms_raw_values[ch] = rms_raw_values[ch] >> 2 ;
                    //str += rms_raw_values[ch] + ', ';
                }
                
                var ADC_full_scale_V = 0.93 ;
                var ADC_raw_max = (1 << 21)  ;
                //var voltage_coefficient =  4.7/(2310 + 4.7) ;
                var voltage_coefficient =  (2310 + 1.4)/1.4 ;
                var current_coefficient =  2500/(240*26/(240+26)) ;
                
                voltage_coefficient = cfg_voltage_multiplier/cfg_voltage_divider ;
                if(cfg_hw_filter & (1<<2)) {
                  current_coefficient = cfg_current_scale_multiplier/cfg_current_scale_divider ;
                } else {
                  current_coefficient = cfg_current_multiplier/cfg_current_divider ;
                }
                //cfg_analog_gain 
                //cfg_digital_gain 

                //console.log('voltage_coefficient: ', cfg_voltage_multiplier, cfg_voltage_divider, voltage_coefficient, ', current_coefficient: ', current_coefficient);
                
                str1 += 'rms  :'
                for (var ch = 0; ch < 3; ch++) {
                    var real_value = rms_raw_values[ch] ;
                    real_value = (real_value / ADC_raw_max) * ADC_full_scale_V  ;
                    real_value = voltage_coefficient * real_value  ;
                    str1 += '__' + real_value.toFixed(4) ;
                }
                for (var ch = 3; ch < 6; ch++) {
                    var real_value = rms_raw_values[ch] ;
                    real_value = (real_value / ADC_raw_max) * ADC_full_scale_V  ;
                    real_value = current_coefficient * real_value  ;
                    str1 += '__' + real_value.toFixed(4);
                }
                
                var angle_raw_values = new Int32Array(7) ;
                var addr_PhAangle_Ua = 0x4001B09C ;
                var _index_PhAangle_Ua = _index + 6 + (addr_PhAangle_Ua - addr_additional_data[0])  ;
                str2 += 'angle :'
                //str += ', raw angle '
                for (var ch = 0; ch < 6; ch++) {
                    angle_raw_values[ch] = ((collected_data[4*ch+_index_PhAangle_Ua+3] << 24) + (collected_data[4*ch+_index_PhAangle_Ua+2] << 16) + (collected_data[4*ch+_index_PhAangle_Ua+1] << 8) + collected_data[4*ch+_index_PhAangle_Ua+0]) ; 
                    //str += angle_raw_values[ch].toString(16) + ', ';
                    if(angle_raw_values[ch] & (0x1 << 23)) { angle_raw_values[ch] += 0xFF000000 ; }
                    var real_angle = angle_raw_values[ch] ;
                    real_angle *= 180/(1<<23) ;
                    str2 += '|||||' + real_angle.toFixed(4); ;
                }
              }
              beginlog(str2);
              beginlog(str1);
              beginlog(str);
              beginlog('-');
              
              SetСhSel(-1) ;
}

var read_write_addr = 0 ;
var read_write_n_items = 0 ;
var read_write_data = new Uint32Array() ;
function parse_input_fields(u8_u32_data_select) {
    read_write_addr = $('input_addr').value ;
    read_write_addr = parseInt(read_write_addr, 16)
    $('input_addr').value = '0x' + read_write_addr.toString(16).toUpperCase() ;

    read_write_n_items = $('input_n').value ;
    read_write_n_items = parseInt(read_write_n_items, 10) ;
    $('input_n').value = read_write_n_items.toString(10) ;

    $('input_data').value.match(/[^\/]+/g);
    read_write_data = $('input_data').value.split(" ").filter(Boolean).map(function (x) { return parseInt(x, 16); });
    console.log(read_write_data, read_write_data.length);
    var s = "";
    for (var i = 0; i < read_write_data.length; i++) {
        if(u8_u32_data_select == 0) {
            s += (read_write_data[i] & 0xFF).toString(16).padStart(2, '0').toUpperCase() + ' ' ;
        } else {
            s += ((read_write_data[i] >> 16) & 0xFFFF).toString(16).padStart(4, '0').toUpperCase() + ((read_write_data[i] >> 0) & 0xFFFF).toString(16).padStart(4, '0').toUpperCase() + ' ' ;
        }
    }
    $('input_data').value = s ;
}

$('read_u8_Btn').addEventListener('click', function() {
  parse_input_fields(0);
  //beginlog("read_u8  [0x" + read_write_addr.toString(16) + '] (' + read_write_n_items + ')');
  wake_build_packet(CMD_READ_MEM_U8, new Uint8Array([read_write_addr, read_write_addr >> 8, read_write_addr >> 16, read_write_addr >> 24, read_write_n_items], ), 5);
  serialController.write_raw(new Uint8Array(wake_out_buf));
});

$('read_u32_Btn').addEventListener('click', function() {
  parse_input_fields(1);
  //beginlog("read_u32  [0x" + read_write_addr.toString(16) + '] (' + read_write_n_items + ')');
  wake_build_packet(CMD_READ_MEM_U32, new Uint8Array([read_write_addr, read_write_addr >> 8, read_write_addr >> 16, read_write_addr >> 24, read_write_n_items], ), 5);
  serialController.write_raw(new Uint8Array(wake_out_buf));
});

$('write_u8_Btn').addEventListener('click', function() {
  parse_input_fields(0);
  var new_data = Uint8Array.from(read_write_data);
  //beginlog("write_u8  [0x" + read_write_addr.toString(16) + '] (' + read_write_n_items + ') {' + new_data + '}');
  wake_build_packet(CMD_WRITE_MEM_U8, new Uint8Array([read_write_addr, read_write_addr >> 8, read_write_addr >> 16, read_write_addr >> 24, read_write_n_items, ...new_data]), 5+new_data.length);
  serialController.write_raw(new Uint8Array(wake_out_buf));
});

$('write_u32_Btn').addEventListener('click', function() {
  parse_input_fields(1);
  var new_data = new Uint8Array(4*read_write_data.length);
  for (var i = 0; i < read_write_data.length; i++) {
    new_data[4*i+0] = read_write_data[i] ;
    new_data[4*i+1] = read_write_data[i] >> 8 ;
    new_data[4*i+2] = read_write_data[i] >> 16 ;
    new_data[4*i+3] = read_write_data[i] >> 24 ;
  }
  //beginlog("write_u32  [0x" + read_write_addr.toString(16) + '] (' + read_write_n_items + ') {' + new_data + '}');
  wake_build_packet(CMD_WRITE_MEM_U32, new Uint8Array([read_write_addr, read_write_addr >> 8, read_write_addr >> 16, read_write_addr >> 24, read_write_n_items, ...new_data] ), 5+new_data.length);
  serialController.write_raw(new Uint8Array(wake_out_buf));
});

$('read_data').addEventListener('click', function() {
    $('input_addr').value = "0x4001B000" ;
    $('input_n').value = "7" ;
    $('read_u32_Btn').click()
});

$('read_angle').addEventListener('click', function() {
    $('input_addr').value = "0x4001B09C" ;
    $('input_n').value = "7" ;
    $('read_u32_Btn').click()
});

$('read_signal_status').addEventListener('click', function() {
    $('input_addr').value = "0x4001B410" ;
    $('input_n').value = "1" ;
    $('read_u32_Btn').click()
});

$('read_d_gain').addEventListener('click', function() {
    $('input_addr').value = "0x4001C07C" ;
    $('input_n').value = "1" ;
    $('read_u32_Btn').click()
});

$('write_d_gain_0').addEventListener('click', function() {
    $('input_addr').value = "0x4001C07C" ;
    $('input_n').value = "1" ;
    $('input_data').value = "0" ;
    $('write_u32_Btn').click()
});

$('write_d_gain_8').addEventListener('click', function() {
    $('input_addr').value = "0x4001C07C" ;
    $('input_n').value = "1" ;
    $('input_data').value = "3FFF" ;
    $('write_u32_Btn').click()
});

$('read_a_gain').addEventListener('click', function() {
    $('input_addr').value = "0x4001C284" ;
    $('input_n').value = "1" ;
    $('read_u32_Btn').click()
});

$('write_a_gain_0').addEventListener('click', function() {
    $('input_addr').value = "0x4001C284" ;
    $('input_n').value = "1" ;
    $('input_data').value = "0" ;
    $('write_u32_Btn').click()
});

$('write_a_gain_max').addEventListener('click', function() {
    $('input_addr').value = "0x4001C284" ;
    $('input_n').value = "1" ;
    $('input_data').value = "7FF" ;
    $('write_u32_Btn').click()
});

$('read_calibr').addEventListener('click', function() {
    $('input_addr').value = "0x3FC00" ;
    $('input_n').value = "8" ;
    $('read_u8_Btn').click()
});

$('write_calibr').addEventListener('click', function() {
    $('input_addr').value = "0x3FC01" ;
    $('input_n').value = "3" ;
    $('input_data').value = "AA BB CC" ;
    $('write_u8_Btn').click()
});


$('read_sn').addEventListener('click', function() {
    $('input_addr').value = "0x40000" ;
    $('input_n').value = "4" ;
    $('read_u8_Btn').click()
});

$('clrBtn').addEventListener('click', function() {
  $('terminal').innerHTML = "";
  datau = [] ; showDataIndex = 0 ;
  ShowGrf();
  stg = 0 ;
});


$('getVerBtn').addEventListener('click', function() {
    wake_build_packet( CMD_GETVER, new Uint8Array([0x00]), 1);
	serialController.write_raw(new Uint8Array(wake_out_buf));
});

$('startCollectionBtn').addEventListener('click', function() {
    wake_build_packet( CMD_START_COLLECT, new Uint8Array([0x40]), 1);
	serialController.write_raw(new Uint8Array(wake_out_buf));
});

$('startCycleCollectionBtn').addEventListener('click', function() {
    wake_build_packet( CMD_START_COLLECT, new Uint8Array([0xC0]), 1);
	serialController.write_raw(new Uint8Array(wake_out_buf));
});

$('setMaskBtn').addEventListener('click', function() {
    var send_byte = 0x00 ;
    if( $('chmask0').checked ) { send_byte |= 1<<0 ; }
    if( $('chmask1').checked ) { send_byte |= 1<<1 ; }
    if( $('chmask2').checked ) { send_byte |= 1<<2 ; }
    if( $('chmask3').checked ) { send_byte |= 1<<3 ; }
    if( $('chmask4').checked ) { send_byte |= 1<<4 ; }
    if( $('chmask5').checked ) { send_byte |= 1<<5 ; }
    if( $('chmask6').checked ) { send_byte |= 1<<6 ; }
    wake_build_packet( CMD_SETMASK, new Uint8Array([send_byte]), 1);
	serialController.write_raw(new Uint8Array(wake_out_buf));
});

$('setMask2048Btn').addEventListener('click', function() {
    var send_byte = 0x00 ;
    if( $('chmask0').checked ) { send_byte |= 1<<0 ; }
    if( $('chmask1').checked ) { send_byte |= 1<<1 ; }
    if( $('chmask2').checked ) { send_byte |= 1<<2 ; }
    if( $('chmask3').checked ) { send_byte |= 1<<3 ; }
    if( $('chmask4').checked ) { send_byte |= 1<<4 ; }
    if( $('chmask5').checked ) { send_byte |= 1<<5 ; }
    if( $('chmask6').checked ) { send_byte |= 1<<6 ; }
    var need_points = 2048 ;
    wake_build_packet( CMD_SETMASK, new Uint8Array([send_byte, need_points & 0xFF, (need_points >> 8) & 0xFF]), 3);
	serialController.write_raw(new Uint8Array(wake_out_buf));
});


$('setMaskAndRegBtn').addEventListener('click', function() {
    var send_byte = 0x00 ;
    if( $('chmask0').checked ) { send_byte |= 1<<0 ; }
    if( $('chmask1').checked ) { send_byte |= 1<<1 ; }
    if( $('chmask2').checked ) { send_byte |= 1<<2 ; }
    if( $('chmask3').checked ) { send_byte |= 1<<3 ; }
    if( $('chmask4').checked ) { send_byte |= 1<<4 ; }
    if( $('chmask5').checked ) { send_byte |= 1<<5 ; }
    if( $('chmask6').checked ) { send_byte |= 1<<6 ; }
    var need_points = 2048 ; //0xFFFF ; //2048 ;
    var reg_start_addr = 0x4001B01C ;
    var reg_items = 0x4001B0B8 - 0x4001B01C ;
    wake_build_packet( CMD_SETMASK, new Uint8Array([send_byte, need_points & 0xFF, (need_points >> 8) & 0xFF, reg_start_addr & 0xFF, (reg_start_addr >> 8) & 0xFF, (reg_start_addr >> 16) & 0xFF, (reg_start_addr >> 24) & 0xFF, reg_items & 0xFF, (reg_items >> 8) & 0xFF]), 9);
	serialController.write_raw(new Uint8Array(wake_out_buf));
});

$('store_calibration_Btn').addEventListener('click', function() {
    wake_build_packet( CMD_STORE_CALIBRATION, new Uint8Array([0x00]), 1);
	serialController.write_raw(new Uint8Array(wake_out_buf));
});

$('read_calibration_Btn').addEventListener('click', function() {
    wake_build_packet( CMD_READ_CALIBRATION, new Uint8Array([0x00]), 1);
	serialController.write_raw(new Uint8Array(wake_out_buf));
});

$('calibr_set_cfg').addEventListener('click', function() {
    var send_byte = 0x00 ;
    if( $('use_hpf_check').checked ) { send_byte |= 1<<0 ; }
    if( $('filter_sel').checked )    { send_byte |= 1<<1 ; }
    if( $('scale_sel').checked )     { send_byte |= 1<<2 ; }
    
    wake_build_packet( CMD_CALIBR_SETTING, new Uint8Array([send_byte]), 1);
	serialController.write_raw(new Uint8Array(wake_out_buf));
});

$('rebootCmdBtn').addEventListener('click', function() {
    wake_build_packet( CMD_REBOOT, new Uint8Array([0x00]), 1);
	serialController.write_raw(new Uint8Array(wake_out_buf));
});

$('SaveBtn').addEventListener('click', function() {
  log('fftsave to csv');
  var csv = convertArrayOfObjectsToCSV({data: datau});
  if (!csv.match(/^data:text\/csv/i)) {csv = 'data:text/csv;charset=utf-8,' + csv;}
  var encodedUri = encodeURI(csv);
  var link = document.createElement('a');
  link.setAttribute('href', encodedUri);
  link.setAttribute('download',cfg_serial_number+"_"+".csv");
  link.click();
});

function download(bytes, fname)  {
  //debugger;
  let blob = new Blob([bytes], {type:"application/octet-stream"});
  let link = document.createElement('a');
  link.href = window.URL.createObjectURL(blob);
  link.download = fname;
  link.click();
}
  
var bufRawData = new Int8Array();
$("butBufSave").onclick =  function() {
    console.log(bufRawData);
    download(bufRawData, cfg_serial_number+"logger3byteData.bin"); 
}

var openFile = function(event) {
  var input = event.target;

  var reader = new FileReader();
  reader.onload = function() {
              parse_collected_data(new Uint8Array(reader.result)) ;
  };
  reader.readAsArrayBuffer(input.files[0]);
};

function convertArrayOfObjectsToCSV(value){
	var result, ctr, keys, columnDelimiter, lineDelimiter, data;

	data = value.data || null;
	if (data == null || !data.length) {return null;}
	columnDelimiter = value.columnDelimiter || ';';
	lineDelimiter = value.lineDelimiter || '\n';
	keys = Object.keys(data[1]);
	result = '';

	data.forEach(function(item){
		ctr = 0;
		keys.forEach(function(key){
			if (ctr > 0)
				result += columnDelimiter;
			result += item[key].toFixed(3).replace(".",",");
			ctr++;
		});
		result += lineDelimiter;
	});
	return result;
}


//-------------------------------------------------------------------
// отображение графика
var gu;
var stg = 0;
var datau = [];
var graphDiv = $('div_v') ;
var graphLab = $('labdiv');
var grapTitle = 'ADC data' ;

function ShowGrf() {
	if(!stg) {
		gu = new Dygraph(
			graphDiv,
		    datau, 
              {
				title: grapTitle ,
				showRangeSelector: true, //true,
				//showRoller: true, //true,
				xlabel: 'n_point',
				ylabel: 'code',
				labels: graph_labels,
				labelsDiv: graphLab,
				legend: "follow", //'always',  // "follow"
				//digitsAfterDecimal: 3,
				//colors: ['green'],
				//axes: { x: {valueFormatter: function(x){return this.getLabels()[0] + ': '+ x.toPrecision(5);}}},
              }
            );
//		setInterval(function(){renderChart()}, 50);
		stg = 1;
	} else {
		gu.updateOptions({'file': datau, 'title': grapTitle});
	}
}

//-----------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------
//WAKE
//-----------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------
const COMM_ADDR_MASTER   = 0x7F; // получатель - мастер линии, ПК или центральный контроллер
const COMM_ADDR_SLAVE    = 0x00; // получатель - все

//стандартные
const CMD_NOP         = 0x00 ; // Нет операции
const CMD_ERR         = 0x01 ; // Передача кода ошибки
const CMD_ECHO        = 0x02 ; // Запрос возврата переданного пакета
const CMD_INFO        = 0x03 ; // Запрос информации об устройстве
const CMD_SETADDR     = 0x04 ; // Установка адреса устройства
const CMD_GETADDR     = 0x05 ; // Чтение адреса устройства
const CMD_GETVER      = 0x10 ; // Чтение адреса устройства
//пользовательские
const CMD_SETMODE     = 0x06 ; // Установка режима работы
const CMD_GETMODE     = 0x07 ; // Чтение режима работы
const CMD_SETMASK     = 0x08 ; // Установка маски
//const CMD_SET_FILTER_CFG   = 0x09 ; // Установка состояния аппаратного фильтра и скалера

const CMD_READ_MEM_U8   = 0x20 ; // Чтение из памяти/регистров
const CMD_READ_MEM_U32  = 0x21 ; // Чтение из памяти/регистров
const CMD_WRITE_MEM_U8  = 0x22 ; // Запись в память/регистры
const CMD_WRITE_MEM_U32 = 0x23 ; // Запись в память/регистры

const CMD_CALIBR_SETTING    = 0x30 ; // Настройка параметров калибровки (HPF)
const CMD_CALIBR_SHIFT      = 0x31 ; // Калибровка смещения
const CMD_CALIBR_GAIN       = 0x32 ; // Калибровка амплитуды
const CMD_CALIBR_PHASE      = 0x33 ; // Калибровка смещения фазы сигнала
const CMD_READ_CALIBRATION  = 0x3E ; // Чтение калибровки из flash
const CMD_STORE_CALIBRATION = 0x3F ; // Сохранение калибровки в flash

const CMD_START_COLLECT    = 0xAA ; // Запуск измерения
const CMD_COLLECTED_DATA   = 0xBB ; // Накопленные данные измерения

const CMD_REBOOT           = 0xFF ; // Перезагрузка

var all_wake_commands = [CMD_NOP, CMD_ERR, CMD_ECHO, CMD_INFO, CMD_SETADDR, CMD_GETADDR, CMD_GETVER, CMD_SETMODE, CMD_GETMODE, CMD_SETMASK, CMD_READ_MEM_U8, CMD_READ_MEM_U32, CMD_WRITE_MEM_U8, CMD_WRITE_MEM_U32, CMD_CALIBR_SETTING, CMD_CALIBR_SHIFT, CMD_CALIBR_GAIN, CMD_CALIBR_PHASE, CMD_READ_CALIBRATION, CMD_STORE_CALIBRATION, CMD_START_COLLECT, CMD_COLLECTED_DATA, CMD_REBOOT] ;

const  START_BYTE_AA  = 0xAA ;
const  START_BYTE_F1  = 0xF1 ;
const  CRC_INIT  = 0xDE ;   //Innitial CRC value

var wake_out_buf = [] ; // new Uint8Array() ; // [] ;

//--------------------- Вычисление контрольной суммы: ------------------------
function Do_Crc8(b, crc)
{
 crc = (crc + b) & 0xFF ;
/*
  for(var i = 0; i < 8; b = b >> 1, i++)
    if((b ^ crc) & 1) crc = ((crc ^ 0x18) >> 1) | 0x80;
     else crc = (crc >> 1) & ~0x80;
*/     
  return crc ;
}


// фомирование пакета для передачи
// на выходе wake_out_buf
// использование
// wake_build_packet(0x0F, new Uint8Array([0x53, 0x54, 0x41, 0x52, 0x54]), 0x05);
// serialController.write_raw(new Uint8Array(wake_out_buf));
function wake_build_packet(_cmd, _in_data, _n_bytes)
{
 var out_bytes = 0 ;
 var wake_byte = 0 ;

 //beginlog('SEND, (' + _cmd.toString(16)+') ' + _in_data.toString(16));
 
 wake_out_buf = wake_out_buf.slice(0, 0) ;
 
 var _crc = CRC_INIT ;
 
 _crc = Do_Crc8(START_BYTE_AA, _crc);
 _crc = Do_Crc8(START_BYTE_F1, _crc);
 _crc = Do_Crc8(_cmd, _crc);
 _crc = Do_Crc8(_n_bytes & 0xFF, _crc);
 _crc = Do_Crc8((_n_bytes >> 8) & 0xFF, _crc);
 for(var _i=0; _i<_n_bytes; _i++) {
      _crc = Do_Crc8(_in_data[_i], _crc);
  }
 
 wake_out_buf.push(START_BYTE_AA);
 wake_out_buf.push(START_BYTE_F1);
 wake_out_buf.push(_cmd);
 
 wake_out_buf.push(_n_bytes);
 wake_out_buf.push(_n_bytes >> 8);
 
 for(var _i=0; _i<_n_bytes; _i++) {
	 wake_out_buf.push(_in_data[_i]);
 }
 
 wake_out_buf.push(_crc);
 
 console.log('WAKE outdata', wake_out_buf);
}


//RX process states:
const  WAIT_START_AA = 0 ; //ожидание приема 
const  WAIT_START_F1 = 1 ; //ожидание приема 
const  WAIT_CMD  = 2 ; //ожидание приема команды
const  WAIT_NBT_L  = 3 ; //ожидание приема количества байт в пакете
const  WAIT_NBT_H  = 4 ; //ожидание приема количества байт в пакете
const  WAIT_DATA = 5 ; //прием данных
const  WAIT_CRC  = 6 ; //ожидание окончания приема CRC
const  RX_DONE   = 7 ; //успешно принят новый пакет
const  RX_CRC_ERR   = 8 ; //

// переменые для приёма
var  Rx_Sta = WAIT_START_AA,        //состояние процесса приема пакета
     Rx_Cmd,        //принятая команда
     Rx_Nbt,        //принятое количество байт в пакете
     Rx_Dat = [],   //массив принятых данных
     Rx_Crc,        //контрольная сумма принимаемого пакета
     Rx_Ptr;        //указатель на массив принимаемых данных

// WAKE приём, побайтово
function parser_wake(data_byte)
{
//console.log('parser_wake :',"data_byte",data_byte, "Rx_Sta",Rx_Sta, "Rx_Nbt", Rx_Nbt, "Rx_Ptr",Rx_Ptr, "Rx_Crc", Rx_Crc);
  switch(Rx_Sta)
  {
  case WAIT_START_AA:                     //-----> ожидание начала фрейма
    {
      if(data_byte == START_BYTE_AA)               //если обнаружено начало фрейма,
      {
        Rx_Crc = CRC_INIT;                //инициализация CRC,
        Rx_Crc = Do_Crc8(data_byte, Rx_Crc);      //обновление CRC,
        Rx_Sta = WAIT_START_F1;               //сброс указателя данных,
      }
    }
  break;
  
  case WAIT_START_F1:                     //-----> ожидание начала фрейма
    {
      if(data_byte == START_BYTE_F1)               //если обнаружено начало фрейма,
      {
        Rx_Crc = Do_Crc8(data_byte, Rx_Crc);      //обновление CRC,
        Rx_Sta = WAIT_CMD;               //сброс указателя данных,
      } else if(data_byte != START_BYTE_AA) {
        Rx_Sta = WAIT_START_AA;
      }
    }
  break;
  
  case WAIT_CMD:                      //-----> ожидание приема команды
    {
	  if( !all_wake_commands.includes(data_byte) )
	   {
		Rx_Sta = WAIT_START_AA;
		break ;
	   }
      Rx_Cmd = data_byte;             //сохранение команды
      Rx_Crc = Do_Crc8(data_byte, Rx_Crc);    //обновление CRC
      Rx_Sta = WAIT_NBT_L;              //переходим к приему количества байт
    }
  break;
  
  case WAIT_NBT_L:                      //-----> ожидание приема количества байт
    {
      Rx_Nbt = data_byte;
      Rx_Crc = Do_Crc8(data_byte, Rx_Crc);    //обновление CRC
      Rx_Ptr = 0;                     //обнуляем указатель данных
      Rx_Sta = WAIT_NBT_H;             //переходим к приему данных
    }
  break;

  case WAIT_NBT_H:                      //-----> ожидание приема количества байт
    {
      Rx_Nbt += (data_byte << 8);
      Rx_Crc = Do_Crc8(data_byte, Rx_Crc);    //обновление CRC
      Rx_Ptr = 0;                     //обнуляем указатель данных
      Rx_Sta = WAIT_DATA;             //переходим к приему данных
      //console.log('parser_wake, Rx_Nbt=', Rx_Nbt);
    }
  break;
  
  case WAIT_DATA:                     //-----> ожидание приема данных
    {
      if(Rx_Ptr < Rx_Nbt)             //если не все данные приняты,
      {
        Rx_Dat[Rx_Ptr++] = data_byte; //то сохранение байта данных,
        Rx_Crc = Do_Crc8(data_byte, Rx_Crc);  //обновление CRC
        break;
      }
      if(data_byte != Rx_Crc)         //если приняты все данные, то проверка CRC
      {
        console.log('parser_wake, error CRC ', data_byte, Rx_Crc, 'CMD', Rx_Cmd, 'Nbt', Rx_Nbt);
        Rx_Sta = RX_CRC_ERR ; //WAIT_START_AA;           //если CRC не совпадает,
        break;
      }
      //console.log('parser_wake, ok CRC ', data_byte, Rx_Crc);
      Rx_Sta = RX_DONE ;             //прием пакета завершен,
      break;
    }
  }

  return(Rx_Sta);
}

</script>

</html>
